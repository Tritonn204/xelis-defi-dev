struct CAsset {
    assetId: u64,
    owner: optional<Address>,
    mintable: bool,
    maxSupply: u64,
    icon: string
}

fn charge(cost: u64, asset: Hash) {
    let deposit: u64 = get_deposit_for_asset(asset).expect("missingAssetDeposit");
    require(cost <= deposit, "depositTooLow");

    let source: Address = Transaction::current().source();

    if deposit > cost {
        let change: u64 = deposit - cost;
        transfer(source, change, asset);
    }

    let owner: Address = Storage::new().load("owner").expect("missingContractOwner");
    transfer(owner, cost, asset);
}

fn newAssetId() -> u64 {
    let storage: Storage = Storage::new();
    let assetId: u64 = storage.load("lastAssetId").expect("missingLastAssetId");
    assetId = assetId + 1;
    storage.store("lastAssetId", assetId);
    return assetId;
}

entry deployAsset(name: string, ticker: string, supply: u64, decimals: u8, mintable: bool, maxSupply: u64, icon: string) {
    let storage: Storage = Storage::new();
    let fee: u64 = storage.load("fee").expect("missingFee");
    let xelis: Hash = Hash::zero();
    charge(fee, xelis);
    
    let assetId: u64 = newAssetId();
    let owner: Address = Transaction::current().source();
    let finalMaxSupply: u64 = 0;
    let asset: optional<Asset>;
    
    if mintable {
        asset = Asset::create(assetId, name, ticker, decimals, null);
        finalMaxSupply = (maxSupply == 0) ? 18446744073709551614 : maxSupply;
    } else {
        asset = Asset::create(assetId, name, ticker, decimals, supply);
        finalMaxSupply = supply;
    }
    
    require(asset.is_some(), "assetNotCreated");
    let createdAsset: Asset = asset.expect("assetCreationFailed");
    
    if mintable {
        createdAsset.mint(supply);
    }
    
    let assetHash: Hash = createdAsset.get_hash()
    transfer(owner, supply, assetHash);
    
    let casset: CAsset = CAsset { 
        assetId: assetId, 
        owner: owner, 
        mintable: mintable, 
        maxSupply: maxSupply, 
        icon: icon
    };
    
    storage.store(assetHash, casset);
    fire_event(1, assetHash);
    return 0;
}

entry mint(assetHash: Hash, amount: u64) {
    let casset: CAsset = Storage::new().load(assetHash).expect("assetNotFound");
    let source: Address = Transaction::current().source();
    
    require(Transaction::current().source() == casset.owner.expect("assetOwnerNotSet"), "notAssetOwner");
    require(casset.mintable, "assetNotMintable");
    
    let asset: Asset = Asset::get_by_id(casset.assetId).expect("assetNotFoundById");
    require((asset.get_supply() + amount) <= casset.maxSupply, "mintOverMax");
    
    asset.mint(amount);
    transfer(source, amount, asset.get_hash());
    return 0;
}

entry transferOwnership(assetHash: Hash, newOwner: Address) {
    let storage: Storage = Storage::new();
    let casset: CAsset = storage.load(assetHash).expect("assetNotFound");
    require(Transaction::current().source() == casset.owner.expect("noAssetOwner"), "notAssetOwner");
    
    casset.owner = newOwner;
    storage.store(assetHash, casset);
    return 0;
}

entry renounceOwnership(assetHash: Hash) {
    let storage: Storage = Storage::new();
    let casset: CAsset = storage.load(assetHash).expect("assetNotFound");
    require(Transaction::current().source() == casset.owner.expect("noAssetOwner"), "notAssetOwner");
    
    casset.owner = null;
    storage.store(assetHash, casset);
    return 0;
}

entry setIcon(assetHash: Hash, newIcon: string) {
    let storage: Storage = Storage::new();
    let casset: CAsset = storage.load(assetHash).expect("assetNotFound");
    require(Transaction::current().source() == casset.owner.expect("noAssetOwner"), "notAssetOwner");
    
    casset.icon = newIcon;
    storage.store(assetHash, casset);
    return 0;
}

entry setFee(newFee: u64) {
    let storage: Storage = Storage::new();
    let owner: Address = storage.load("owner").expect("missingContractOwner");
    require(Transaction::current().source() == owner, "notContractOwner");
    storage.store("fee", newFee);
    return 0;
}

hook constructor() -> u64 {
    let storage: Storage = Storage::new();
    storage.store("lastAssetId", 0);
    storage.store("owner", Transaction::current().source());
    storage.store("fee", 1 * 10 ** 8);
    return 0;
}